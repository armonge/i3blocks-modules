#!/usr/bin/env bash

################################################################################
#
# CUSTOM PLUGIN SECTION
#
################################################################################

############################################################
# Variables
############################################################

###
### Custom Defines
###
appname="date"
time="${BLOCK_INSTANCE:-%H:%M}"
format=" {time}"


###
### Thresholds
###
has_threshold=1


###
### Additional arguments
###
arg_params=(
	"-t"
)
arg_vars=(
	"time"
)
arg_desc_val=(
	"<time>"
)
arg_desc_long=(
	"Specify time format. This can also be set via i3blocks 'instance=' value. If neither is set, it will default to '%H:%M'."
)


###
### Format placeholders
###

# bash variable names
format_vars=(
	time
)

# Format placeholders
format_nodes=(
	"{time}"
)

# Format description (for help display)
format_descs=(
	"Date time format"
)

# Format examples (for help display)
format_examples=(
	"-f \" {time}\""
	"-f \" {time}\" -t \"%a, %d.%m.%Y\""
)


############################################################
# custom_actio function
############################################################

###
### Evaluate disk space
###
custom_action() {
	time="$( date "+${time}" )"
}




###
###
###
###    D O   N O T   E D I T   A F T E R   H E R E
###
###
###




################################################################################
#
# BUILT-IN VARIABLES
#
################################################################################

###
### General default values
###
color_def="#666666"		# gray
color_good="#88b090"	# green
color_warn="#ccdc90"	# yellow
color_crit="#e89393"	# red
color_info="#fce94f"	# bright yellow

###
### Use of pango markup?
###
pango=1


###
### source configuration file if it exists
###
if [ -f "${HOME}/.config/i3blocks/contrib.conf" ]; then
	. "${HOME}/.config/i3blocks/contrib.conf"
fi


###
### i3blocks vars info
### https://vivien.github.io/i3blocks/
###
# name=		${BLOCK_NAME}
# instace=	${BLOCK_INSTANCE}
# button=	${BLOCK_BUTTON}
# x-coor	${BLOCK_X}
# y-coor	${BLOCK_Y}


################################################################################
#
# BUILT-IN FUNCTIONS
#
################################################################################

###
### System functions
###
print_usage() {
	custom_args=""

	# program specific arguments
	for (( i=0; i<${#arg_params[@]}; i++ )); do
		custom_args="${custom_args}[${arg_params[$i]} ${arg_desc_val[$i]}] "
	done

	# Show/Hide threshold
	if [ "${has_threshold}" = "1" ]; then
		custom_args="${custom_args}[-tg|-ti|-tw|-tc <p> <s> <int|str>] "
	fi

	echo "Usage: ${appname} [-f <format>] ${custom_args}[-np] [-cd|-cg|-cw|-cc|-ci <code>]"
	echo "       ${appname} -h"
	echo "       ${appname} -v"
	echo

	if [ "${#custom_args}" -gt "0" ]; then
		echo "Optional variables:"
		echo "--------------------------------------------------------------------------------"

		for (( i=0; i<${#arg_params[@]}; i++ )); do
			printf "  %-13s%s\n" "${arg_params[$i]} ${arg_desc_val[$i]}" "${arg_desc_long[$i]}"
		done
		echo
	fi

	if [ "${has_threshold}" = "1" ]; then
		echo "Optional threshold arguments:"
		echo "--------------------------------------------------------------------------------"
		echo "You can optionally enable threshold checking against any placeholder value."
		echo "This enables the colorizing of the final output depending on any met"
		echo "conditions specified."
		echo "Default is not to use any threshold"
		echo "  -tg <p> <s> <int|str>   Enable threshold for 'good status'"
		echo "  -ti <p> <s> <int|str>   Enable threshold for 'info status'"
		echo "  -tw <p> <s> <int|str>   Enable threshold for 'warn status'"
		echo "  -tc <p> <s> <int|str>   Enable threshold for 'crit status'"
		echo
		echo "   Explanation:"
		echo "     <p>   is the placeholder value you want to check against."
		printf "           valid placeholders: "
		for (( i=0; i<${#format_nodes[@]}; i++ )); do
			printf "%s" "${format_nodes[$i]} "
		done
		printf "\n"
		echo "           Note 1: placeholder values will be converted to integers"
		echo "                   Any decimal places will simply be cut off."
		echo "           Note 2: In equal mode (<s> '=') is a string comparison and"
		echo "                   no placeholder will be converted."
		echo "           Note 3: In equal mode (<s> '=') regex is allowed :-)"
		echo "     <s>   must either be '<', '>' or '=' depending on what direction"
		echo "           you want to check the threshold placeholder against."
		echo "     <int> The integer number you want to check against the placeholder."
		echo "     <str> The string you want to check against the placeholder."
		echo "           You can only use a string when in equal mode '='."
		echo "           You can also use regex here."
		echo
		echo "   Examples:"
		echo "     1. Check if value of ${format_nodes[0]} < 50, then format using the good color"
		echo "     -tg '${format_nodes[0]}' '<' 50"
		echo
		echo "     2. Check if value of ${format_nodes[0]} > 90, then format using the warn color"
		echo "     -tw '${format_nodes[0]}' '>' 90"
		echo
		echo "     3. Check if value of ${format_nodes[0]} equals the string 'foo', then format using the info color"
		echo "     -ti '${format_nodes[0]}' '=' 'foo'"
		echo
		echo "     4. Check if value of ${format_nodes[0]} equals the regex '^[0-9]+\$', then format using the info color"
		echo "     -ti '${format_nodes[0]}' '=' '^[0-9]+\$'"
		echo
	fi

	echo "Optional markup (pango):"
	echo "--------------------------------------------------------------------------------"
	echo "  -np          Disable pango markup"
	echo

	echo "Optional color arguments:"
	echo "--------------------------------------------------------------------------------"
	echo "If not specified, script default colors are used"
	echo "If config file with color codes is present in:"
	echo "'${HOME}/.config/i3blocks/contrib.conf', these colors will be used."
	echo
	echo "  -cd <code>   Default color (hexadecimal color code)"
	echo "               Default value is: ${color_def}"
	echo "  -cg <code>   Good color (hexadecimal color code)"
	echo "               Default value is: ${color_good}"
	echo "  -cw <code>   Warning color (hexadecimal color code)"
	echo "               Default value is: ${color_warn}"
	echo "  -cc <code>   Critical color (hexadecimal color code)"
	echo "               Default value is: ${color_crit}"
	echo "  -ci <code>   Info color (hexadecimal color code)"
	echo "               Default value is: ${color_info}"
	echo

	echo "Optional Format placeholders:"
	echo "--------------------------------------------------------------------------------"
	echo "  Available color placeholders:"
	echo "  (Use with pango disabled for custom markup) building"
	echo "     {color}        Current active color depending on thresholds"
	echo "     {color_def}    Default color"
	echo "     {color_good}   Good color"
	echo "     {color_warn}   Warning color"
	echo "     {color_crit}   Critical color"
	echo "     {color_info}   Info color"
	echo "  Format example:"
	echo "     -np -f \"<span color='{color}'>Colored text</span>\""
	echo

	echo "  Available specific placeholders:"
	for (( i=0; i<${#format_nodes[@]}; i++ )); do
		printf "     %-15s%s\n" "${format_nodes[$i]}" "${format_descs[$i]}"
	done

	echo "  Format example:"
	for (( i=0; i<${#format_examples[@]}; i++ )); do
		printf "     %s\n" "${format_examples[$i]}"
	done
	echo "  Default:"
	echo "     -f \"${format}\""
}

print_version() {
	echo "${appname} v1.1 by cytopia"
	echo "https://github.com/cytopia/i3blocks-modules"
}

###
### Decide about final output color color
###
get_status_color() {
	local _color_def="${1}"
	local _color_good="${2}"
	local _color_warn="${3}"
	local _color_crit="${4}"
	local _color_info="${5}"

	# final color
	local _color="${_color_def}"

	local pval

	# has good color?
	if [ "${tg_placeholder}" != "" ]; then
		if [ "${tg_sign}" = "=" ]; then
			pval="${!tg_placeholder}"
		else
			pval="$( echo "${!tg_placeholder}" | grep -oE '[0-9]*' | head -1 )"
		fi

		if [ "${tg_sign}" = "<" ]; then
			if [ "${pval}" -lt "${tg_value}" ]; then
				_color="${color_good}"
			fi
		elif [ "${tg_sign}" = "=" ]; then
			if [[ "${pval}" =~ ${tg_value} ]]; then
				_color="${color_good}"
			fi
		elif [ "${tg_sign}" = ">" ]; then
			if [ "${pval}" -gt "${tg_value}" ]; then
				_color="${color_good}"
			fi
		fi
	fi

	# has info color?
	if [ "${ti_placeholder}" != "" ]; then
		if [ "${ti_sign}" = "=" ]; then
			pval="${!ti_placeholder}"
		else
			pval="$( echo "${!ti_placeholder}" | grep -oE '[0-9]*' | head -1 )"
		fi

		if [ "${ti_sign}" = "<" ]; then
			if [ "${pval}" -lt "${ti_value}" ]; then
				_color="${color_info}"
			fi
		elif [ "${ti_sign}" = "=" ]; then
			if [[ "${pval}" =~ ${ti_value} ]]; then
				_color="${color_info}"
			fi
		elif [ "${ti_sign}" = ">" ]; then
			if [ "${pval}" -gt "${ti_value}" ]; then
				_color="${color_info}"
			fi
		fi
	fi

	# has warn color?
	if [ "${tw_placeholder}" != "" ]; then
		if [ "${tw_sign}" = "=" ]; then
			pval="${!tw_placeholder}"
		else
			pval="$( echo "${!tw_placeholder}" | grep -oE '[0-9]*' | head -1 )"
		fi

		if [ "${tw_sign}" = "<" ]; then
			if [ "${pval}" -lt "${tw_value}" ]; then
				_color="${color_warn}"
			fi
		elif [ "${tw_sign}" = "=" ]; then
			if [[ "${pval}" =~ ${tw_value} ]]; then
				_color="${color_warn}"
			fi
		elif [ "${tw_sign}" = ">" ]; then
			if [ "${pval}" -gt "${tw_value}" ]; then
				_color="${color_warn}"
			fi
		fi
	fi

	# has crit color?
	if [ "${tc_placeholder}" != "" ]; then
		if [ "${tc_sign}" = "=" ]; then
			pval="${!tc_placeholder}"
		else
			pval="$( echo "${!tc_placeholder}" | grep -oE '[0-9]*' | head -1 )"
		fi

		if [ "${tc_sign}" = "<" ]; then
			if [ "${pval}" -lt "${tc_value}" ]; then
				_color="${color_crit}"
			fi
		elif [ "${tc_sign}" = "=" ]; then
			if [[ "${pval}" =~ ${tc_value} ]]; then
				_color="${color_crit}"
			fi
		elif [ "${tc_sign}" = ">" ]; then
			if [ "${pval}" -gt "${tc_value}" ]; then
				_color="${color_crit}"
			fi
		fi
	fi
	echo "${_color}"
}


###
### Replace custom stuff in format string
###
replace_placeholders() {
	local format="${1}"

	for (( i=0; i < ${#format_nodes[@]}; i++ )); do
		replace="${format_vars[$i]}"
		format="$( echo "${format}" | sed "s/${format_nodes[$i]}/${!replace}/g" )"
	done
	echo "${format}"
}


###
### Replace colors in format string
###
replace_colors() {
	local _format="${1}"
	local _color="${2}"
	local _color_def="${3}"
	local _color_good="${4}"
	local _color_warn="${5}"
	local _color_crit="${6}"
	local _color_info="${7}"

	_format="$( echo "${_format}" | sed "s/{color}/${_color}/g" )"
	_format="$( echo "${_format}" | sed "s/{color_def}/${_color_def}/g" )"
	_format="$( echo "${_format}" | sed "s/{color_good}/${_color_good}/g" )"
	_format="$( echo "${_format}" | sed "s/{color_warn}/${_color_warn}/g" )"
	_format="$( echo "${_format}" | sed "s/{color_crit}/${_color_crit}/g" )"
	_format="$( echo "${_format}" | sed "s/{color_info}/${_color_info}/g" )"

	echo "${_format}"
}



################################################################################
#
# MAIN ENTRY POINT
#
################################################################################

# Enable/Disable threshold argument
if [ "${has_threshold}" = "1" ]; then
	th_chk=""
else
	th_chk="__THRESHOLD_DISABLED__"
fi


while [ $# -gt 0  ]; do
	case "$1" in
		###
		### Threshold good
		###
		-tg${th_chk})
			tg_placeholder=
			tg_sign=
			tg_value=

			# 1/3 Check placeholder
			shift
			if [ "${1}" = "" ]; then
				echo "Error, -tg <p> - no placeholder specified."
				exit 1
			fi
			f=0
			for (( i=0; i < ${#format_nodes[@]}; i++ )); do
				if [ "${format_nodes[$i]}" = "${1}" ]; then
					f=1
					break
				fi
			done
			if [ "${f}" = "0" ]; then
				echo "Error, -tg '${1}' no such placeholder."
				exit 1
			fi
			tg_placeholder="${format_vars[$i]}"

			# 2/3 Check sign
			shift
			if [ "${1}" = "" ]; then
				echo "Error, -tg '${tg_placeholder}' '${1}' - sign is empty."
				exit 1
			fi
			if [ "${1}" != "<" ] && [ "${1}" != ">" ] && [ "${1}" != "=" ]; then
				echo "Error, -tg '${tg_placeholder}' '${1}' - invalid sign: '${1}'."
				exit 1
			fi
			tg_sign="${1}"

			# 3/3 Check value
			shift
			if [ "${1}" = "" ]; then
				echo "Error, -tg '${tg_placeholder}' '${tg_sign}' '${1}' - value is empty."
				exit 1
			fi
			if [ "${tg_sign}" != "=" ]; then
				if ! printf "%d" "${1}" >/dev/null 2>&1; then
					echo "Error, -tg '${tg_placeholder}' '${tg_sign}' '${1}' is not a number."
					exit 1
				fi
			fi
			tg_value="${1}"
			;;
		###
		### Threshold info
		###
		-ti${th_chk})
			ti_placeholder=
			ti_sign=
			ti_value=

			# 1/3 Check placeholder
			shift
			if [ "${1}" = "" ]; then
				echo "Error, -ti <p> - no placeholder specified."
				exit 1
			fi
			f=0
			for (( i=0; i < ${#format_nodes[@]}; i++ )); do
				if [ "${format_nodes[$i]}" = "${1}" ]; then
					f=1
					break
				fi
			done
			if [ "${f}" = "0" ]; then
				echo "Error, -ti '${1}' no such placeholder."
				exit 1
			fi
			ti_placeholder="${format_vars[$i]}"

			# 2/3 Check sign
			shift
			if [ "${1}" = "" ]; then
				echo "Error, -ti '${ti_placeholder}' '${1}' - sign is empty."
				exit 1
			fi
			if [ "${1}" != "<" ] && [ "${1}" != ">" ] && [ "${1}" != "=" ]; then
				echo "Error, -ti '${ti_placeholder}' '${1}' - invalid sign: '${1}'."
				exit 1
			fi
			ti_sign="${1}"

			# 3/3 Check value
			shift
			if [ "${1}" = "" ]; then
				echo "Error, -ti '${ti_placeholder}' '${ti_sign}' '${1}' - value is empty."
				exit 1
			fi
			if [ "${ti_sign}" != "=" ]; then
				if ! printf "%d" "${1}" >/dev/null 2>&1; then
					echo "Error, -ti '${ti_placeholder}' '${ti_sign}' '${1}' is not a number."
					exit 1
				fi
			fi
			ti_value="${1}"
			;;
		###
		### Threshold warn
		###
		-tw${th_chk})
			tw_placeholder=
			tw_sign=
			tw_value=

			# 1/3 Check placeholder
			shift
			if [ "${1}" = "" ]; then
				echo "Error, -tw <p> - no placeholder specified."
				exit 1
			fi
			f=0
			for (( i=0; i < ${#format_nodes[@]}; i++ )); do
				if [ "${format_nodes[$i]}" = "${1}" ]; then
					f=1
					break
				fi
			done
			if [ "${f}" = "0" ]; then
				echo "Error, -tw '${1}' no such placeholder."
				exit 1
			fi
			tw_placeholder="${format_vars[$i]}"

			# 2/3 Check sign
			shift
			if [ "${1}" = "" ]; then
				echo "Error, -tw '${tw_placeholder}' '${1}' - sign is empty."
				exit 1
			fi
			if [ "${1}" != "<" ] && [ "${1}" != ">" ] && [ "${1}" != "=" ]; then
				echo "Error, -tw '${tw_placeholder}' '${1}' - invalid sign: '${1}'."
				exit 1
			fi
			tw_sign="${1}"

			# 3/3 Check value
			shift
			if [ "${1}" = "" ]; then
				echo "Error, -tw '${tw_placeholder}' '${tw_sign}' '${1}' - value is empty."
				exit 1
			fi
			if [ "${tw_sign}" != "=" ]; then
				if ! printf "%d" "${1}" >/dev/null 2>&1; then
					echo "Error, -tw '${tw_placeholder}' '${tw_sign}' '${1}' is not a number."
					exit 1
				fi
			fi
			tw_value="${1}"
			;;
		###
		### Threshold crit
		###
		-tc${th_chk})
			tc_placeholder=
			tc_sign=
			tc_value=

			# 1/3 Check placeholder
			shift
			if [ "${1}" = "" ]; then
				echo "Error, -tc <p> - no placeholder specified."
				exit 1
			fi
			f=0
			for (( i=0; i < ${#format_nodes[@]}; i++ )); do
				if [ "${format_nodes[$i]}" = "${1}" ]; then
					f=1
					break
				fi
			done
			if [ "${f}" = "0" ]; then
				echo "Error, -tc '${1}' no such placeholder."
				exit 1
			fi
			tc_placeholder="${format_vars[$i]}"

			# 2/3 Check sign
			shift
			if [ "${1}" = "" ]; then
				echo "Error, -tc '${tc_placeholder}' '${1}' - sign is empty."
				exit 1
			fi
			if [ "${1}" != "<" ] && [ "${1}" != ">" ] && [ "${1}" != "=" ]; then
				echo "Error, -tc '${tc_placeholder}' '${1}' - invalid sign: '${1}'."
				exit 1
			fi
			tc_sign="${1}"

			# 3/3 Check value
			shift
			if [ "${1}" = "" ]; then
				echo "Error, -tc '${tc_placeholder}' '${tw_sign}' '${1}' - value is empty."
				exit 1
			fi
			if [ "${tc_sign}" != "=" ]; then
				if ! printf "%d" "${1}" >/dev/null 2>&1; then
					echo "Error, -tc '${tc_placeholder}' '${tc_sign}' '${1}' is not a number."
					exit 1
				fi
			fi
			tc_value="${1}"
			;;
		###
		### Format overwrite
		###
		-f)
			shift
			format="${1}"
			;;
		###
		### Disable pango markup output
		###
		-np)
			pango=0
			;;
		###
		### Color overwrites
		###
		-cd)
			# default color
			shift
			if ! echo "${1}" | grep -qE '#[0-9a-fA-F]{6}' >/dev/null 2>&1; then
				echo "Error, invalid color string: ${1}"
				exit 1
			fi
			color_def="${1}"
			;;
		-cg)
			# good color
			shift
			if ! echo "${1}" | grep -qE '#[0-9a-fA-F]{6}' >/dev/null 2>&1; then
				echo "Error, invalid color string: ${1}"
				exit 1
			fi
			color_good="${1}"
			;;
		-cw)
			# warning color
			shift
			if ! echo "${1}" | grep -qE '#[0-9a-fA-F]{6}' >/dev/null 2>&1; then
				echo "Error, invalid color string: ${1}"
				exit 1
			fi
			color_warn="${1}"
			;;
		-cc)
			# critical color
			shift
			if ! echo "${1}" | grep -qE '#[0-9a-fA-F]{6}' >/dev/null 2>&1; then
				echo "Error, invalid color string: ${1}"
				exit 1
			fi
			color_crit="${1}"
			;;
		-ci)
			# info color
			shift
			if ! echo "${1}" | grep -qE '#[0-9a-fA-F]{6}' >/dev/null 2>&1; then
				echo "Error, invalid color string: ${1}"
				exit 1
			fi
			color_info="${1}"
			;;
		###
		### System options
		###
		-h)
			print_usage
			exit 0
			;;
		-v)
			print_version
			exit 0
			;;
		###
		### Unknown/Custom option
		###
		*)

			###
			### Evaluate user-specified arguments
			###
			found=0
			if [ "${#arg_params}" -gt "0" ]; then
				for (( i=0; i<${#arg_params[@]}; i++ )); do
					if [ "${arg_params[$i]}" = "${1}" ]; then
						shift
						var_name="${arg_vars[$i]}"
						eval "${var_name}=\"${1}\""
						found=1
						break;
					fi
				done
			fi

			###
			### Unknown option
			###
			if [ "${found}" = "0" ]; then
				echo "Invalid argument: '${1}'"
				print_usage
				exit 1
			fi
			;;
	esac
	shift
done




###
### Call custom function
###
custom_action

###
### Get final output color (based on custom specs)
###
color="$( get_status_color "${color_def}" "${color_good}" "${color_warn}" "${color_crit}" "${color_info}" )"

###
### Format (colors)
###
format="$( replace_colors "${format}" "${color}" "${color_def}" "${color_good}" "${color_warn}" "${color_crit}" "${color_info}" )"

###
### Format (custom)
###
format="$( replace_placeholders "${format}" )"


###
### Output pango or plain style?
###
if [ "${pango}" = "1" ]; then
	echo "<span color=\"${color}\">${format}</span>"
else
	echo "${format}"	# Long output
	echo "${format}"	# short output
	echo "\\${color}"	# color code '\#RRGGBB'
fi

exit 0
